import json
import os

import boto3
import requests
from botocore.exceptions import ClientError
import logging

env = os.environ.get('ENV')
log_level = os.environ.get('LOG_LEVEL')
if log_level == 'DEBUG':
    logging.getLogger().setLevel(logging.DEBUG)
elif log_level == 'ERROR':
    logging.getLogger().setLevel(logging.ERROR)
else:
    logging.getLogger().setLevel(logging.INFO)


def lambda_handler(event, context):
    logging.info('ADMPの外部システム連携開始')
    # 環境変数を取得
    url = os.environ.get('ADMP_API_HOST')
    api_key = os.environ.get('ZOOM_API_KEY')
    headers = {'x-api-key': api_key}

    if not env or not url or not api_key:
        logging.error("環境変数「ADMP_API_HOST」「ZOOM_API_KEY」「ENV」取得失敗")
        res_body = {
            "code": "E000",
            "message": "予期せぬエラーが発生しました"
        }
        return {
            "statusCode": 400,
            "headers": {
                "Content-Type": "application/json"
            },
            "body": json.dumps(res_body)
        }
    try:
        # ADMPの外部システム連携の「端末の一覧取得API」で取得する
        get_devices(url, headers)
        # ADMPの外部システム連携の「テナントの一覧取得API」で取得する
        get_tenants(url, headers)
        # ADMPの外部システム連携の「コミュニティの一覧取得API」で取得する
        get_communities(url, headers)
        # ADMPの外部システム連携の「ロケーションの一覧取得API」で取得する
        get_locations(url, headers)
    except Exception as e:
        logging.error(e)
    response = {
        "statusCode": 200,
        "body": json.dumps({})
    }
    return response


# devicesテーブル情報の同期
def get_devices(url, headers):
    logging.info('デバイスの一覧取得開始')
    # ADMPデバイスの一覧取得
    params = {
        "updatedAt": get_max_updated_at('devices')
    }

    devices = requests.post(url + '/devices', headers=headers, data=params)
    if devices.status_code == 400:
        logging.error('deviceの一覧取得失敗')
        logging.error(devices.json())
        return devices
    list_to_insert = []
    list_to_update = []
    old_devices = scan_db('devices')
    if devices.json():
        if old_devices:
            old_dict = {item["id"]: item for item in old_devices}
            for item in devices.json():
                if item['deviceId'] not in old_dict:
                    list_to_insert.append(item)
                elif item['deviceId'] in old_dict:
                    if str(item['updatedAt']) != old_dict[item['deviceId']]['updated_at']:
                        list_to_update.append(item)
        else:
            list_to_insert = devices.json()
    if list_to_insert:
        items = []
        for item in list_to_insert:
            new_item = {
                "id": item.get('deviceId'),  # 端末ID
                "community_id": item.get('communityId'),  # コミュニティID
                "serial": item.get('serial'),
                "created_at": str(item.get('createdAt')),  # 登録日時
                "updated_at": str(item.get('updatedAt')),  # 更新日時
                "deleted_at": str(item.get('deletedAt'))  # 削除日時
            }
            items.append(new_item)
        writer_batch('devices', items)
    if list_to_update:
        for item in list_to_update:
            new_item = {
                "id": item.get('deviceId'),  # 端末ID
                "community_id": item.get('communityId'),  # コミュニティID
                "serial": item.get('serial'),
                "created_at": str(item.get('createdAt')),  # 登録日時
                "updated_at": str(item.get('updatedAt')),  # 更新日時
                "deleted_at": str(item.get('deletedAt'))  # 削除日時
            }
            update_item_db('devices', new_item)
    logging.info('デバイスの一覧取得終了')
    return {}


# tenantsテーブル情報の同期
def get_tenants(url, headers):
    # ADMPテナントの一覧取得
    logging.info('テナントの一覧取得開始')
    params = {
        "updatedAt": get_max_updated_at('tenants')
    }
    tenants = requests.post(url + '/tenants', headers=headers, data=params)
    if tenants.status_code == 400:
        logging.error('tenantの一覧取得失敗')
        logging.error(tenants.json())
        return tenants
    list_to_insert = []
    list_to_update = []
    old_tenants = scan_db('tenants')
    if tenants.json():
        if old_tenants:
            old_dict = {item["id"]: item for item in old_tenants}
            for item in tenants.json():
                if item['tenantId'] not in old_dict:
                    list_to_insert.append(item)
                elif item['tenantId'] in old_dict:
                    if str(item['updatedAt']) != old_dict[item['tenantId']]['updated_at']:
                        list_to_update.append(item)
        else:
            list_to_insert = tenants.json()
    if list_to_insert:
        items = []
        for item in list_to_insert:
            new_item = {
                "id": item.get('tenantId'),  # テナントID
                "name": item.get('name'),  # 事業者名
                "name_kana": item.get('nameKana'),  # 事業者名（全角カナ）
                "disabled_at": str(item.get('disabledAt')),  # 無効状態切替日時
                "created_at": str(item.get('createdAt')),  # 登録日時
                "updated_at": str(item.get('updatedAt')),  # 更新日時
                "deleted_at": str(item.get('deletedAt'))  # 削除日時
            }
            items.append(new_item)
        writer_batch('tenants', items)
    if list_to_update:
        for item in list_to_update:
            new_item = {
                "id": item.get('tenantId'),  # テナントID
                "name": item.get('name'),  # 事業者名
                "name_kana": item.get('nameKana'),  # 事業者名（全角カナ）
                "disabled_at": str(item.get('disabledAt')),  # 無効状態切替日時
                "created_at": str(item.get('createdAt')),  # 登録日時
                "updated_at": str(item.get('updatedAt')),  # 更新日時
                "deleted_at": str(item.get('deletedAt'))  # 削除日時
            }
            update_item_db('tenants', new_item)
    logging.info('テナントの一覧取得終了')
    return {}


# communitiesテーブル情報の同期
def get_communities(url, headers):
    # ADMPコミュニティの一覧取得
    logging.info('コミュニティの一覧取得開始')
    params = {
        "updatedAt": get_max_updated_at('communities')
    }
    communities = requests.post(url + '/communities', headers=headers, data=params)
    if communities.status_code == 400:
        logging.error('communityの一覧取得失敗')
        logging.error(communities.json())
        return communities
    list_to_insert = []
    list_to_update = []
    old_communities = scan_db('communities')
    if communities.json():
        if old_communities:
            old_dict = {item["id"]: item for item in old_communities}
            for item in communities.json():
                if item['communityId'] not in old_dict:
                    list_to_insert.append(item)
                elif item['communityId'] in old_dict:
                    if str(item['updatedAt']) != old_dict[item['communityId']]['updated_at']:
                        list_to_update.append(item)
        else:
            list_to_insert = communities.json()
    if list_to_insert:
        items = []
        for item in list_to_insert:
            new_item = {
                "id": item.get('communityId'),  # コミュニティID
                "tenant_id": item.get('tenantId'),  # テナントID
                "name": item.get('name'),  # コミュニティ名
                "disabled_at": str(item.get('disabledAt')),  # 無効状態切替日時
                "created_at": str(item.get('createdAt')),  # 登録日時
                "updated_at": str(item.get('updatedAt')),  # 更新日時
                "deleted_at": str(item.get('deletedAt'))  # 削除日時
            }
            items.append(new_item)
        writer_batch('communities', items)
    if list_to_update:
        for item in list_to_update:
            new_item = {
                "id": item.get('communityId'),  # コミュニティID
                "tenant_id": item.get('tenantId'),  # テナントID
                "name": item.get('name'),  # コミュニティ名
                "disabled_at": str(item.get('disabledAt')),  # 無効状態切替日時
                "created_at": str(item.get('createdAt')),  # 登録日時
                "updated_at": str(item.get('updatedAt')),  # 更新日時
                "deleted_at": str(item.get('deletedAt'))  # 削除日時
            }
            update_item_db('communities', new_item)
    logging.info('コミュニティの一覧取得終了')
    return {}


# locationsテーブル情報の同期
def get_locations(url, headers):
    # ADMP locationの一覧取得
    logging.info('locationの一覧取得開始')
    params = {
        "updatedAt": get_max_updated_at('locations')
    }
    locations = requests.post(url + '/locations', headers=headers, data=params)
    if locations.status_code == 400:
        logging.error('locationの一覧取得失敗')
        logging.error(locations.json())
        return locations
    list_to_insert = []
    list_to_update = []
    old_locations = scan_db('locations')
    if locations.json():
        if old_locations:
            old_dict = {item["id"]: item for item in old_locations}
            for item in locations.json():
                if item['locationId'] not in old_dict:
                    list_to_insert.append(item)
                elif item['locationId'] in old_dict:
                    if str(item['updatedAt']) != old_dict[item['locationId']]['updated_at']:
                        list_to_update.append(item)
        else:
            list_to_insert = locations.json()
    if list_to_insert:
        items = []
        for item in list_to_insert:
            new_item = {
                "id": item.get('locationId'),  # ロケーションID
                "device_id": item.get('deviceId'),  # 端末ID
                "disabled_at": str(item.get('disabledAt')),  # 無効状態切替日時
                "created_at": str(item.get('createdAt')),  # 登録日時
                "updated_at": str(item.get('updatedAt')),  # 更新日時
                "deleted_at": str(item.get('deletedAt'))  # 削除日時
            }
            items.append(new_item)
        writer_batch('locations', items)
    if list_to_update:
        for item in list_to_update:
            new_item = {
                "id": item.get('locationId'),  # ロケーションID
                "device_id": item.get('deviceId'),  # 端末ID
                "disabled_at": str(item.get('disabledAt')),  # 無効状態切替日時
                "created_at": str(item.get('createdAt')),  # 登録日時
                "updated_at": str(item.get('updatedAt')),  # 更新日時
                "deleted_at": str(item.get('deletedAt'))  # 削除日時
            }
            update_item_db('locations', new_item)
    logging.info('locationの一覧取得終了')
    return {}


# 获取最大更新日時
def get_max_updated_at(table):
    table = env + '_' + table
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table(table)

    response = table.scan(
        ExpressionAttributeNames={
            "#ut": "updated_at"
        },
        ProjectionExpression="#ut",
        Limit=1,
        FilterExpression="attribute_exists(updated_at)",
        Select="SPECIFIC_ATTRIBUTES"
    )

    items = response.get('Items', [])
    updated_at = 0
    if items:
        updated_at = max(items, key=lambda x: x['updated_at'])
    logging.info('最大更新日時:' + str(updated_at))
    return updated_at

def update_item_db(table, new_item):
    table = env + '_' + table
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table(table)
    try:
        response = table.put_item(Item=new_item)
    except ClientError as e:
        logging.error(e)
        logging.error(new_item)
        return {
            "code": "E000",
            "message": "予期せぬエラーが発生しました"
        }
    else:
        return response


def writer_batch(table, items):
    table = env + '_' + table
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table(table)
    with table.batch_writer() as batch:
        batch_size = 10
        item_batches = [items[i:i + batch_size] for i in range(0, len(items), batch_size)]
        for item_batche in item_batches:
            for item in item_batche:
                try:
                    batch.put_item(Item=item)
                except ClientError as e:
                    logging.error(e)
                    logging.error(item)              


def scan_db(table, scan_kwargs=None):
    table = env + '_' + table
    if scan_kwargs is None:
        scan_kwargs = {}
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table(table)

    complete = False
    records = []
    while not complete:
        try:
            response = table.scan(**scan_kwargs)
        except ClientError as e:
            logging.error(e)
            return {
                "code": "E000",
                "message": "予期せぬエラーが発生しました"
            }

        records.extend(response.get('Items', []))
        next_key = response.get('LastEvaluatedKey')
        if next_key:
            scan_kwargs['ExclusiveStartKey'] = next_key

        complete = True if next_key is None else False
    return records
